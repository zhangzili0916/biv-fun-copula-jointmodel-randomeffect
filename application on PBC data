library(pracma)
library(cubature)
library(expm)
library("copula")
library(CVTuningCov)
library(JM)
library(joineR)
library(nlme)
library("abind")
library("magic")
library("matrixcalc")
library(Deriv)
library(mvtnorm)
library(emdbook)
library(latex2exp)
library(tikzDevice)
library(fda)
library(VineCopula)

GaussianHermite <- function(r)
{
  esp <- 3.0e-14
  pim4 <- 1/sqrt(sqrt(pi)) 	
  maxit <- 1000
  x <- w <- rep(0,r) 
  m <- (r+1 - ((r+1)%%2))/2
  p <- 2*r
  q <- 2*r+1
  for(i in 1:m){
    if(i==1) z <- sqrt(q) -1.85575*q^(-.1667)
    if(i==2) z <- z-1.14^((.425)/z)
    if(i==3) z <- 1.86*z - 0.86*x[1]
    if(i==4) z <- 1.91*z - 0.91*x[2]
    if(i!=1 & i!=2 & i!=3 & i!=4)  z <- 2*z - x[i-2]
    its <- 1
    dif <- 1
    while(its<maxit & dif>esp){
      p1 <- pim4
      p2 <- 0
      for(j in 1:r){
        p3 <- p2
        p2 <- p1
        p1 <- z*sqrt(2/j)*p2 - sqrt((j-1)/j)*p3
      }
      pp <- sqrt(p)*p2
      z <- z - p1/pp
      dif <- abs(p1/pp)
      its <- its +1
    }
    x[i] <- z
    x[r+1-i] <- -z
    w[i] <- 2/(pp^2)
    w[r+1-i] <- w[i]
  }
  return(list(round(w,15),round(x,15)))
}


pbc2$status2=as.numeric(pbc2$status!= "alive")         #transplanted and death are treated as a composite event
pbc2$logserBilir=log(pbc2$serBilir)
pbc2.id$status2=as.numeric(pbc2.id$status != "alive")

#use "joint" function from "joineR" to fit pbc data to get initial value 
pbc.long=pbc2[,c("id","logserBilir","year")]
pbc.surv=pbc2.id[,c("id","years","status2")]
pbc.cov =pbc2.id[,c("id","sex","drug","age")]
pbc.jd1=jointdata(longitudinal = pbc.long,
                   baseline = pbc.cov,
                   survival = pbc.surv,
                   id.col = "id",
                   time.col = "year")
pbcfit <- joint(data =pbc.jd1,
                 long.formula = logserBilir~ year+drug+sex+age,
                 surv.formula = Surv(years,status2) ~ drug+sex+age,
                 model = "intslope",sepassoc=F)
summary(pbcfit)

#0.7071505+0.1832956*t is the linear population mean trajectory from "joint" function, transfer it into linear
#combination of B-spline basis functions
reversePBCmu.linear=function(nmu,n,tmax,muord)
{
  mu=0.7071505+0.1832956*seq(0,tmax,length=n)
  Phi=eval.basis(seq(0,tmax,length=n),create.bspline.basis(c(0,tmax),nmu,muord))
  return(solve(t(Phi)%*%Phi)%*%t(Phi)%*%mu)
}

#log-likelihood for the functional bivariate Gaussian copula joint model
appPBCbivGaucoploglik.funrhoty.mu=function(theta,data,m,neta,nmu,etaord,muord,nlam,tmax)
{
  beta1=theta[1:3]
  beta2=theta[4:6]
  D11=theta[7]
  D22=theta[8]
  D12=theta[9]
  etapar=theta[10:(9+neta)]
  lambda=theta[(10+neta):(9+neta+nlam)]
  sigma=theta[10+neta+nlam]
  alpha=theta[11+neta+nlam]
  mupar=theta[(12+neta+nlam):(11+neta+nlam+nmu)]
  n=length(unique(data$id))
  a=GaussianHermite(m)[[2]]
  w=GaussianHermite(m)[[1]]
  D=matrix(c(D11,D12,D12,D22),ncol=2)
  ll=-1.0e40
  if(sigma>0&sum(lambda>rep(0,nlam))==nlam&is.positive.definite(D)>0)
  {
    ll=0
    for(sub in 1:n)
    {
      timepoint=data$year[data$id==sub]
      etaty=eval.basis(timepoint,create.bspline.basis(c(0,tmax),nbasis=neta,norder=etaord))%*%etapar
      rhoty=(exp(2*etaty)-1)/(exp(2*etaty)+1)
      ni=length(timepoint)
      Xi1=matrix(c(as.numeric(data$drug[data$id==sub])-1,
                   as.numeric(data$sex[data$id==sub])-1,data$age[data$id==sub]),ncol=3)
      Zi1=matrix(c(rep(1,ni),timepoint),ncol=2)
      Xi2=c(unique(as.numeric(data$drug[data$id==sub])-1),unique(as.numeric(data$sex[data$id==sub])-1),
            unique(data$age[data$id==sub]))
      obsti=unique(data$years[data$id==sub])
      indi=unique(data$status2[data$id==sub])
      V11=Zi1%*%D%*%t(Zi1)+sigma^2*diag(ni)
      V22=D
      V12=Zi1%*%D
      V21=t(V12)
      mu=eval.basis(timepoint,create.bspline.basis(c(0,tmax),nbasis=nmu,norder=muord))%*%mupar
      mubiconyi=V21%*%solve(V11)%*%(log(data$serBilir)[data$id==sub]-Xi1%*%beta1-mu)
      Sigmabiconyi=V22-V21%*%solve(V11)%*%V12
      roti1=matrix(c(cos(pi/4),sin(pi/4),-sin(pi/4),cos(pi/4)),ncol=2)
      roti=eigen(Sigmabiconyi)$vector%*%diag(sqrt(eigen(Sigmabiconyi)$value))%*%roti1
      bij=sqrt(2)*roti%*%t(as.matrix(expand.grid(a,a)))+c(mubiconyi)
      wij=expand.grid(w,w)[,1]*expand.grid(w,w)[,2]/pi
      Cij=lambda%*%t(exp(c(Xi2%*%beta2)+alpha*bij[1,]))
      numbasi=sum(obsti>seq(0,max(data$years),length=nlam+1))
      nodei=c(seq(0,max(data$years),length=nlam+1)[1:numbasi],obsti)
      Zyij=(matrix(rep(log(data$serBilir)[data$id==sub],m^2),ncol=m^2)-matrix(rep(Xi1%*%beta1+mu,m^2),ncol=m^2)-Zi1%*%bij)/sigma
      postijcondimean=1
      if(ni>1)
      {
        for(k in 1:(ni-1))
        {
          nodeik=c(timepoint[k],nodei[nodei>timepoint[k]][which(nodei[nodei>timepoint[k]] %in% nodei[nodei<timepoint[k+1]])],timepoint[k+1])
          numbasik=length(nodeik)-1
          lownumbasik=sum(timepoint[k]>=nodei)
          upnumbasik=sum(timepoint[k+1]>nodei)
          Sijk=exp(colSums(-Cij[lownumbasik:upnumbasik,]/(matrix(rep(alpha*bij[2,],numbasik),byrow=T,nrow=numbasik))*
                             (exp(nodeik[2:(numbasik+1)]%*%t(alpha*bij[2,]))-exp(nodeik[1:numbasik]%*%t(alpha*bij[2,])))))
          Zyijk=Zyij[k,]
          mutijkcon=rhoty[k]*Zyijk
          sigmatijkcon=sqrt(1-rhoty[k]^2)
          ftijkcon=pnorm((qnorm(Sijk)+mutijkcon)/sigmatijkcon)
          postijcondimean=ftijkcon*postijcondimean  
        }
      }
      if(obsti!=timepoint[ni])
      {
        nodeini=c(timepoint[ni],nodei[nodei>timepoint[ni]][which(nodei[nodei>timepoint[ni]] %in% nodei[nodei<obsti])],obsti)
        numbasini=length(nodeini)-1
        lownumbasini=sum(timepoint[ni]>=nodei)
        upnumbasini=numbasi
        hijni=Cij[upnumbasini,]*exp(alpha*bij[2,]*obsti)
        Sijni=exp(colSums(-Cij[lownumbasini:upnumbasini,]/(matrix(rep(alpha*bij[2,],numbasini),byrow=T,nrow=numbasini))*
                            (exp(nodeini[2:(numbasini+1)]%*%t(alpha*bij[2,]))-exp(nodeini[1:numbasini]%*%t(alpha*bij[2,])))))
        fijni=hijni*Sijni
        Zyijni=Zyij[ni,]
        mutijnicon=rhoty[ni]*Zyijni
        sigmatijnicon=sqrt(1-rhoty[ni]^2)
        ftijnicon=indi*dnorm(-qnorm(Sijni),mutijnicon,sigmatijnicon)*fijni/dnorm(-qnorm(Sijni))+
          (1-indi)*(pnorm((qnorm(Sijni)+mutijnicon)/sigmatijnicon))
      } else {ftijnicon=1}
      posticondimean=sum(wij*postijcondimean*ftijnicon)
      ll=ll+(-ni/2*log(2*pi)-0.5*log(det(V11))-0.5*t((log(data$serBilir)[data$id==sub]-Xi1%*%beta1-mu))%*%
               solve(V11)%*%(log(data$serBilir)[data$id==sub]-Xi1%*%beta1-mu)+log(posticondimean))
    }
  }
  if(is.na(ll)) ll=-1.0e40
  if(abs(ll)==Inf) ll=-1.0e40
  return(-ll)
}

#log-likelihood for the regular joint model.
appPBCbivGaucoploglik.0rhoty.funmu=function(theta,data,m,nmu,muord,nlam,tmax)
{
  beta1=theta[1:3]
  beta2=theta[4:6]
  D11=theta[7]
  D22=theta[8]
  D12=theta[9]
  lambda=theta[10:(9+nlam)]
  sigma=theta[10+nlam]
  alpha=theta[11+nlam]
  mupar=theta[(12+nlam):(11+nlam+nmu)]
  n=length(unique(data$id))
  a=GaussianHermite(m)[[2]]
  w=GaussianHermite(m)[[1]]
  D=matrix(c(D11,D12,D12,D22),ncol=2)
  ll=-1.0e40
  if(sigma>0&sum(lambda>rep(0,nlam))==nlam&is.positive.definite(D)>0)
  {
    ll=0
    for(sub in 1:n)
    {
      timepoint=data$year[data$id==sub]
      ni=length(timepoint)
      Xi1=matrix(c(as.numeric(data$drug[data$id==sub])-1,
                   as.numeric(data$sex[data$id==sub])-1,data$age[data$id==sub]),ncol=3)
      Zi1=matrix(c(rep(1,ni),timepoint),ncol=2)
      Xi2=c(unique(as.numeric(data$drug[data$id==sub])-1),unique(as.numeric(data$sex[data$id==sub])-1),
            unique(data$age[data$id==sub]))
      obsti=unique(data$years[data$id==sub])
      indi=unique(data$status2[data$id==sub])
      V11=Zi1%*%D%*%t(Zi1)+sigma^2*diag(ni)
      V22=D
      V12=Zi1%*%D
      V21=t(V12)
      mu=eval.basis(timepoint,create.bspline.basis(c(0,tmax),nbasis=nmu,norder=muord))%*%mupar
      mubiconyi=V21%*%solve(V11)%*%(log(data$serBilir)[data$id==sub]-Xi1%*%beta1-mu)
      Sigmabiconyi=V22-V21%*%solve(V11)%*%V12
      roti1=matrix(c(cos(pi/4),sin(pi/4),-sin(pi/4),cos(pi/4)),ncol=2)
      roti=eigen(Sigmabiconyi)$vector%*%diag(sqrt(eigen(Sigmabiconyi)$value))%*%roti1
      bij=sqrt(2)*roti%*%t(as.matrix(expand.grid(a,a)))+c(mubiconyi)
      wij=expand.grid(w,w)[,1]*expand.grid(w,w)[,2]/pi
      Cij=lambda%*%t(exp(c(Xi2%*%beta2)+alpha*bij[1,]))
      numbasi=sum(obsti>seq(0,max(data$years),length=nlam+1))
      nodei=c(seq(0,max(data$years),length=nlam+1)[1:numbasi],obsti)
      postijcondimean=1
      if(ni>1)
      {
        for(k in 1:(ni-1))
        {
          nodeik=c(timepoint[k],nodei[nodei>timepoint[k]][which(nodei[nodei>timepoint[k]] %in% nodei[nodei<timepoint[k+1]])],timepoint[k+1])
          numbasik=length(nodeik)-1
          lownumbasik=sum(timepoint[k]>=nodei)
          upnumbasik=sum(timepoint[k+1]>nodei)
          Sijk=exp(colSums(-Cij[lownumbasik:upnumbasik,]/(matrix(rep(alpha*bij[2,],numbasik),byrow=T,nrow=numbasik))*
                             (exp(nodeik[2:(numbasik+1)]%*%t(alpha*bij[2,]))-exp(nodeik[1:numbasik]%*%t(alpha*bij[2,])))))
          postijcondimean=Sijk*postijcondimean  
        }
      }
      if(obsti!=timepoint[ni])
      {
        nodeini=c(timepoint[ni],nodei[nodei>timepoint[ni]][which(nodei[nodei>timepoint[ni]] %in% nodei[nodei<obsti])],obsti)
        numbasini=length(nodeini)-1
        lownumbasini=sum(timepoint[ni]>=nodei)
        upnumbasini=numbasi
        hijni=Cij[upnumbasini,]*exp(alpha*bij[2,]*obsti)
        Sijni=exp(colSums(-Cij[lownumbasini:upnumbasini,]/(matrix(rep(alpha*bij[2,],numbasini),byrow=T,nrow=numbasini))*
                            (exp(nodeini[2:(numbasini+1)]%*%t(alpha*bij[2,]))-exp(nodeini[1:numbasini]%*%t(alpha*bij[2,])))))
        fijni=hijni*Sijni
        ftijnicon=indi*fijni+(1-indi)*Sijni
      } else {ftijnicon=1}
      posticondimean=sum(wij*postijcondimean*ftijnicon)
      ll=ll+(-ni/2*log(2*pi)-0.5*log(det(V11))-0.5*t((log(data$serBilir)[data$id==sub]-Xi1%*%beta1-mu))%*%
               solve(V11)%*%(log(data$serBilir)[data$id==sub]-Xi1%*%beta1-mu)+log(posticondimean))
    }
  }
  if(is.na(ll)) ll=-1.0e40
  if(abs(ll)==Inf) ll=-1.0e40
  return(-ll)
}


#log-likelihood for the regular joint model, this is equivalent to "appPBCbivGaucoploglik.0rhoty.funmu"
appPBCbivGaucoploglik.uncor.funmu=function(theta,data,m,nmu,muord,nlam,tmax)
{
  beta1=theta[1:3]
  beta2=theta[4:6]
  D11=theta[7]
  D22=theta[8]
  D12=theta[9]
  lambda=theta[10:(9+nlam)]
  sigma=theta[10+nlam]
  alpha=theta[11+nlam]
  mupar=theta[(12+nlam):(11+nlam+nmu)]
  n=length(unique(data$id))
  a=GaussianHermite(m)[[2]]
  w=GaussianHermite(m)[[1]]
  D=matrix(c(D11,D12,D12,D22),ncol=2)
  ll=-1.0e40
  if(sigma>0&sum(lambda>rep(0,nlam))==nlam&is.positive.definite(D)>0)
  {
    ll=0
    for(sub in 1:n)
    {
      timepoint=data$year[data$id==sub]
      ni=length(timepoint)
      Xi1=matrix(c(as.numeric(data$drug[data$id==sub])-1,
                   as.numeric(data$sex[data$id==sub])-1,data$age[data$id==sub]),ncol=3)
      Zi1=matrix(c(rep(1,ni),timepoint),ncol=2)
      Xi2=c(unique(as.numeric(data$drug[data$id==sub])-1),unique(as.numeric(data$sex[data$id==sub])-1),
            unique(data$age[data$id==sub]))
      obsti=unique(data$years[data$id==sub])
      indi=unique(data$status2[data$id==sub])
      V11=Zi1%*%D%*%t(Zi1)+sigma^2*diag(ni)
      V22=D
      V12=Zi1%*%D
      V21=t(V12)
      mu=eval.basis(timepoint,create.bspline.basis(c(0,tmax),nbasis=nmu,norder=muord))%*%mupar
      mubiconyi=V21%*%solve(V11)%*%(log(data$serBilir)[data$id==sub]-Xi1%*%beta1-mu)
      Sigmabiconyi=V22-V21%*%solve(V11)%*%V12
      roti1=matrix(c(cos(pi/4),sin(pi/4),-sin(pi/4),cos(pi/4)),ncol=2)
      roti=eigen(Sigmabiconyi)$vector%*%diag(sqrt(eigen(Sigmabiconyi)$value))%*%roti1
      bij=sqrt(2)*roti%*%t(as.matrix(expand.grid(a,a)))+c(mubiconyi)
      wij=expand.grid(w,w)[,1]*expand.grid(w,w)[,2]/pi
      Cij=lambda%*%t(exp(c(Xi2%*%beta2)+alpha*bij[1,]))
      numbasi=sum(obsti>seq(0,max(data$years),length=nlam+1))
      nodei=c(seq(0,max(data$years),length=nlam+1)[1:numbasi],obsti)
      Sij=exp(colSums(-Cij[1:numbasi,]/(matrix(rep(alpha*bij[2,],numbasi),byrow=T,nrow=numbasi))*
                             (exp(nodei[2:(numbasi+1)]%*%t(alpha*bij[2,]))-exp(nodei[1:numbasi]%*%t(alpha*bij[2,])))))
      hij=Cij[numbasi,]*exp(alpha*bij[2,]*obsti)
      fij=hij*Sij
      ftijcon=indi*fij+(1-indi)*Sij
      posticondimean=sum(wij*ftijcon)
      ll=ll+(-ni/2*log(2*pi)-0.5*log(det(V11))-0.5*t((log(data$serBilir)[data$id==sub]-Xi1%*%beta1-mu))%*%
               solve(V11)%*%(log(data$serBilir)[data$id==sub]-Xi1%*%beta1-mu)+log(posticondimean))
    }
  }
  if(is.na(ll)) ll=-1.0e40
  if(abs(ll)==Inf) ll=-1.0e40
  return(-ll)
}


#log-likelihood for the functional bivariate t copula joint model
appPBCbivtcoploglik.funrhoty.mu=function(theta,data,m,neta,nmu,etaord,muord,nlam,tmax,nu)  
{
  beta1=theta[1:3]
  beta2=theta[4:6]
  D11=theta[7]
  D22=theta[8]
  D12=theta[9]
  etapar=theta[10:(9+neta)]
  lambda=theta[(10+neta):(9+neta+nlam)]
  sigma=theta[10+neta+nlam]
  alpha=theta[11+neta+nlam]
  mupar=theta[(12+neta+nlam):(11+neta+nlam+nmu)]
  n=length(unique(data$id))
  a=GaussianHermite(m)[[2]]
  w=GaussianHermite(m)[[1]]
  D=matrix(c(D11,D12,D12,D22),ncol=2)
  ll=-1.0e40
  if(sigma>0&sum(lambda>rep(0,nlam))==nlam&is.positive.definite(D)>0)
  {
    ll=0
    for(sub in 1:n)
    {
      timepoint=data$year[data$id==sub]
      etaty=eval.basis(timepoint,create.bspline.basis(c(0,tmax),nbasis=neta,norder=etaord))%*%etapar
      rhoty=(exp(2*etaty)-1)/(exp(2*etaty)+1)
      ni=length(timepoint)
      Xi1=matrix(c(as.numeric(data$drug[data$id==sub])-1,as.numeric(data$sex[data$id==sub])-1,data$age[data$id==sub]),ncol=3)
      Zi1=matrix(c(rep(1,ni),timepoint),ncol=2)
      Xi2=c(unique(as.numeric(data$drug[data$id==sub])-1),unique(as.numeric(data$sex[data$id==sub])-1),unique(data$age[data$id==sub]))
      obsti=unique(data$years[data$id==sub])
      indi=unique(data$status2[data$id==sub])
      V11=Zi1%*%D%*%t(Zi1)+sigma^2*diag(ni)
      V22=D
      V12=Zi1%*%D
      V21=t(V12)
      mu=eval.basis(timepoint,create.bspline.basis(c(0,tmax),nbasis=nmu,norder=muord))%*%mupar
      mubiconyi=V21%*%solve(V11)%*%(log(data$serBilir)[data$id==sub]-Xi1%*%beta1-mu)
      Sigmabiconyi=V22-V21%*%solve(V11)%*%V12
      roti1=matrix(c(cos(pi/4),sin(pi/4),-sin(pi/4),cos(pi/4)),ncol=2)
      roti=eigen(Sigmabiconyi)$vector%*%diag(sqrt(eigen(Sigmabiconyi)$value))%*%roti1
      bij=sqrt(2)*roti%*%t(as.matrix(expand.grid(a,a)))+c(mubiconyi)
      wij=expand.grid(w,w)[,1]*expand.grid(w,w)[,2]/pi
      Cij=lambda%*%t(exp(c(Xi2%*%beta2)+alpha*bij[1,]))
      numbasi=sum(obsti>seq(0,max(data$years),length=nlam+1))
      nodei=c(seq(0,max(data$years),length=nlam+1)[1:numbasi],obsti)
      Wyij=qt(pnorm((matrix(rep(log(data$serBilir)[data$id==sub],m^2),ncol=m^2)-matrix(rep(Xi1%*%beta1+mu,m^2),ncol=m^2)-Zi1%*%bij)/sigma),df=nu)
      postijcondimean=1
      if(ni>1)
      {
        for(k in 1:(ni-1))
        {
          nodeik=c(timepoint[k],nodei[nodei>timepoint[k]][which(nodei[nodei>timepoint[k]] %in% nodei[nodei<timepoint[k+1]])],timepoint[k+1])
          numbasik=length(nodeik)-1
          lownumbasik=sum(timepoint[k]>=nodei)
          upnumbasik=sum(timepoint[k+1]>nodei)
          Sijk=exp(colSums(-Cij[lownumbasik:upnumbasik,]/(matrix(rep(alpha*bij[2,],numbasik),byrow=T,nrow=numbasik))*
                             (exp(nodeik[2:(numbasik+1)]%*%t(alpha*bij[2,]))-exp(nodeik[1:numbasik]%*%t(alpha*bij[2,])))))
          Wyijk=Wyij[k,]
          mutijkcon=rhoty[k]*Wyijk
          sigmatijkcon=sqrt((nu+Wyijk^2)*(1-rhoty[k]^2)/(nu+1))
          ftijkcon=pt((qt(Sijk,df=nu)+mutijkcon)/sigmatijkcon,df=nu+1)
          postijcondimean=ftijkcon*postijcondimean  
        }
      }
      if(obsti!=timepoint[ni])
      {
        nodeini=c(timepoint[ni],nodei[nodei>timepoint[ni]][which(nodei[nodei>timepoint[ni]] %in% nodei[nodei<obsti])],obsti)
        numbasini=length(nodeini)-1
        lownumbasini=sum(timepoint[ni]>=nodei)
        upnumbasini=numbasi
        hijni=Cij[upnumbasini,]*exp(alpha*bij[2,]*obsti)
        Sijni=exp(colSums(-Cij[lownumbasini:upnumbasini,]/(matrix(rep(alpha*bij[2,],numbasini),byrow=T,nrow=numbasini))*
                            (exp(nodeini[2:(numbasini+1)]%*%t(alpha*bij[2,]))-exp(nodeini[1:numbasini]%*%t(alpha*bij[2,])))))
        fijni=hijni*Sijni
        Wyijni=Wyij[ni,]
        mutijnicon=rhoty[ni]*Wyijni
        sigmatijnicon=sqrt((nu+Wyijni^2)*(1-rhoty[ni]^2)/(nu+1))
        ftijnicon=indi*(dt((-qt(Sijni,df=nu)-mutijnicon)/sigmatijnicon,df=nu+1)/sigmatijnicon)*fijni/dt(-qt(Sijni,df=nu),df=nu)+
          (1-indi)*pt((qt(Sijni,df=nu)+mutijnicon)/sigmatijnicon,df=nu+1)
      } else {ftijnicon=1}
      posticondimean=sum(wij*postijcondimean*ftijnicon)
      ll=ll+(-ni/2*log(2*pi)-0.5*log(det(V11))-0.5*t((log(data$serBilir)[data$id==sub]-Xi1%*%beta1-mu))%*%
               solve(V11)%*%(log(data$serBilir)[data$id==sub]-Xi1%*%beta1-mu)+log(posticondimean))
    }
  }
  if(is.na(ll)) ll=-1.0e40
  if(abs(ll)==Inf) ll=-1.0e40
  return(-ll)
}

#get estimation from the regular joint model
appPBCbivGaucoploglik.0rhoty.funmu(theta=c(-0.1328304,-0.1887005,0.00007142636,-0.21634319,-0.20325232,0.04238101,0.987860,0.032477,0.076584,rep(0.009,7),
                              0.12062911^0.5,1.291969,reversePBCmu.linear(4,21,max(pbc2$year),muord=4)),data=pbc2,m=3,nmu=4,muord=4,nlam=7,tmax=max(pbc2$year))

appPBCbivGaucoploglik.uncor.funmu(theta=c(-0.1328304,-0.1887005,0.00007142636,-0.21634319,-0.20325232,0.04238101,0.987860,0.032477,0.076584,rep(0.009,7),
                              0.12062911^0.5,1.291969,reversePBCmu.linear(4,21,max(pbc2$year),muord=4)),data=pbc2,m=3,nmu=4,muord=4,nlam=7,tmax=max(pbc2$year))

#get estimation from the bivaraite functional Gaussian copula joint model 
estPBCGaucop.eta5.mu4.BS5.BS4.7ba.nlm=nlm(f=appPBCbivGaucoploglik.funrhoty.mu,p=c(-0.1328304,-0.1887005,0.00007142636,-0.21634319,-0.20325232,0.04238101,
                              0.987860,0.032477,0.076584,rep(0,5),rep(0.009,7),0.12062911^0.5,1.291969,reversePBCmu.linear(4,21,max(pbc2$year),muord=4)),
                              data=pbc2,neta=5,nmu=4,etaord=5,muord=4,m=3,tmax=max(pbc2$year),nlam=7,hessian=T,iterlim=1000)        

#get estimation from the bivaraite functional t copula joint model with df=11
estPBCt11cop.eta5.mu4.BS5.BS4.7ba.nlm=nlm(f=appPBCbivtcoploglik.funrhoty.mu,p=c(-0.1328304,-0.1887005,0.00007142636,-0.21634319,-0.20325232,0.04238101,
                              0.987860,0.032477,0.076584,rep(0,5),rep(0.009,7),0.12062911^0.5,1.291969,reversePBCmu.linear(4,21,max(pbc2$year),muord=4)),
                              data=pbc2,neta=5,nmu=4,muord=4,etaord=5,m=3,tmax=max(pbc2$year),nlam=7,nu=11,hessian=T,iterlim=1000)
                              
#Dynamic prediction on PBC data
#posterior distribution of random effect bi, i.e., f(bi|ti,yi), for bivaraite functional Gaussian copula joint model
fbiPBCposGau=function(beta1,beta2,D11,D22,D12,etapar,lambda,sigma,alpha,mupar,muord,etaord,data,dynati,bi,m,tmax)
{
  timepoint=data$year
  ni=length(timepoint)
  D=matrix(c(D11,D12,D12,D22),ncol=2)
  a=GaussianHermite(m)[[2]]
  w=GaussianHermite(m)[[1]]
  Xi1=matrix(c(as.numeric(data$drug)-1,as.numeric(data$sex)-1,data$age),ncol=3)
  Zi1=matrix(c(rep(1,ni),timepoint),ncol=2)
  Xi2=c(unique(as.numeric(data$drug)-1),unique(as.numeric(data$sex)-1),unique(data$age))
  mu=eval.basis(timepoint,create.bspline.basis(c(0,tmax),nbasis=length(mupar),norder=muord))%*%mupar
  etaty=eval.basis(timepoint,create.bspline.basis(c(0,tmax),nbasis=length(etapar),norder=etaord))%*%etapar
  rhoty=(exp(2*etaty)-1)/(exp(2*etaty)+1)
  event=unique(data$status2)
  obsti=unique(data$years)
  if(dynati<obsti) {indi=0
  ti=dynati} else {indi=event
  ti=obsti}
  dimyi=sum(timepoint<=ti)
  V11=matrix(Zi1[1:dimyi,],ncol=2)%*%D%*%t(matrix(Zi1[1:dimyi,],ncol=2))+sigma^2*diag(dimyi)
  V22=D
  V12=matrix(Zi1[1:dimyi,],ncol=2)%*%D
  V21=t(V12)
  mubiconyi=V21%*%solve(V11)%*%(log(data$serBilir)-Xi1%*%beta1-mu)[1:dimyi,]
  Sigmabiconyi=V22-V21%*%solve(V11)%*%V12
  Ci=c(lambda,lambda[length(lambda)])*exp(c(Xi2%*%beta2)+alpha*bi[1])
  numbasi=sum(ti>seq(0,max(pbc2$years),length=length(lambda)+1))           
  nodei=c(seq(0,max(pbc2$years),length=length(lambda)+1)[1:numbasi],ti)
  ftikconyibi=1
  if(dimyi>1)
  {
    for(k in 1:(dimyi-1))
    {
      nodeik=c(timepoint[k],nodei[nodei>timepoint[k]][which(nodei[nodei>timepoint[k]] %in% nodei[nodei<timepoint[k+1]])],timepoint[k+1])
      numbasik=length(nodeik)-1
      lownumbasik=sum(timepoint[k]>=nodei)
      upnumbasik=sum(timepoint[k+1]>nodei)
      Sik=exp(sum(-Ci[lownumbasik:upnumbasik]/(alpha*bi[2])*(exp(alpha*bi[2]*nodeik[2:(numbasik+1)])-exp(alpha*bi[2]*nodeik[1:numbasik]))))   
      Zyik=(log(data$serBilir)-Xi1%*%beta1-mu-Zi1%*%bi)[k,]/sigma
      mutikconyibi=rhoty[k]*Zyik
      sigmatikconyibi=sqrt(1-rhoty[k]^2)
      Stikconyibi=pnorm((qnorm(Sik)+mutikconyibi)/sigmatikconyibi)
      ftikconyibi=ftikconyibi*Stikconyibi 
    }
  }
  if(ti!=timepoint[dimyi])
  {
    nodeini=c(timepoint[dimyi],nodei[nodei>timepoint[dimyi]][which(nodei[nodei>timepoint[dimyi]] %in% nodei[nodei<ti])],ti)
    numbasini=length(nodeini)-1
    lownumbasini=sum(timepoint[dimyi]>=nodei)
    upnumbasini=numbasi
    hini=Ci[upnumbasini]*exp(alpha*bi[2]*ti)
    Sini=exp(sum(-Ci[lownumbasini:upnumbasini]/(alpha*bi[2])*(exp(alpha*bi[2]*nodeini[2:(numbasini+1)])-exp(alpha*bi[2]*nodeini[1:numbasini]))))
    fini=hini*Sini
    Zyini=(log(data$serBilir)-Xi1%*%beta1-mu-Zi1%*%bi)[dimyi,]/sigma
    mutiniconyibi=rhoty[dimyi]*Zyini
    sigmatiniconyibi=sqrt(1-rhoty[dimyi]^2)
    ftiniconyibi=indi*dnorm(-qnorm(Sini),mutiniconyibi,sigmatiniconyibi)*fini/dnorm(-qnorm(Sini))+
      (1-indi)*(pnorm((qnorm(Sini)+mutiniconyibi)/sigmatiniconyibi))
  } else {ftiniconyibi=1}
  fticonyibi=ftikconyibi*ftiniconyibi
  ftijkconyibi=1
  roti1=matrix(c(cos(pi/4),sin(pi/4),-sin(pi/4),cos(pi/4)),ncol=2)
  roti=eigen(Sigmabiconyi)$vector%*%diag(sqrt(eigen(Sigmabiconyi)$value))%*%roti1
  bij=sqrt(2)*roti%*%t(as.matrix(expand.grid(a,a)))+c(mubiconyi)
  wij=expand.grid(w,w)[,1]*expand.grid(w,w)[,2]/pi
  Cij=c(lambda,lambda[length(lambda)])%*%t(exp(c(Xi2%*%beta2)+alpha*bij[1,]))
  if(dimyi>1)
  {
    for(k in 1:(dimyi-1))
    {
      nodeik=c(timepoint[k],nodei[nodei>timepoint[k]][which(nodei[nodei>timepoint[k]] %in% nodei[nodei<timepoint[k+1]])],timepoint[k+1])
      numbasik=length(nodeik)-1
      lownumbasik=sum(timepoint[k]>=nodei)
      upnumbasik=sum(timepoint[k+1]>nodei)
      Sijk=exp(colSums(-Cij[lownumbasik:upnumbasik,]/(matrix(rep(alpha*bij[2,],numbasik),byrow=T,nrow=numbasik))*
                         (exp(nodeik[2:(numbasik+1)]%*%t(alpha*bij[2,]))-exp(nodeik[1:numbasik]%*%t(alpha*bij[2,])))))  
      Zyijk=(matrix(rep(log(data$serBilir),m^2),ncol=m^2)-matrix(rep(Xi1%*%beta1+mu,m^2),ncol=m^2)-Zi1%*%bij)[k,]/sigma
      mutijkconyibi=rhoty[k]*Zyijk
      sigmatijkconyibi=sqrt(1-rhoty[k]^2)
      Stijkconyibi=pnorm((qnorm(Sijk)+mutijkconyibi)/sigmatijkconyibi)
      ftijkconyibi=ftijkconyibi*Stijkconyibi 
    }
  }
  if(ti!=timepoint[dimyi])
  {
    nodeini=c(timepoint[dimyi],nodei[nodei>timepoint[dimyi]][which(nodei[nodei>timepoint[dimyi]] %in% nodei[nodei<ti])],ti)
    numbasini=length(nodeini)-1
    lownumbasini=sum(timepoint[dimyi]>=nodei)
    upnumbasini=numbasi
    hijni=Cij[upnumbasini,]*exp(alpha*bij[2,]*ti)
    Sijni=exp(colSums(-Cij[lownumbasini:upnumbasini,]/(matrix(rep(alpha*bij[2,],numbasini),byrow=T,nrow=numbasini))*
                        (exp(nodeini[2:(numbasini+1)]%*%t(alpha*bij[2,]))-exp(nodeini[1:numbasini]%*%t(alpha*bij[2,])))))
    fijni=hijni*Sijni  
    Zyijni=(matrix(rep(log(data$serBilir),m^2),ncol=m^2)-matrix(rep(Xi1%*%beta1+mu,m^2),ncol=m^2)-Zi1%*%bij)[dimyi,]/sigma
    mutijniconyibi=rhoty[dimyi]*Zyijni
    sigmatijniconyibi=sqrt(1-rhoty[dimyi]^2)
    ftijniconyibi=indi*dnorm(-qnorm(Sijni),mutijniconyibi,sigmatijniconyibi)*fijni/dnorm(-qnorm(Sijni))+
      (1-indi)*(pnorm((qnorm(Sijni)+mutijniconyibi)/sigmatijniconyibi))
  } else {ftijniconyibi=1}
  fticonyi=sum(ftijkconyibi*ftijniconyibi*wij)
  fbiconyiti=fticonyibi*dmvnorm(bi,c(mubiconyi),Sigmabiconyi)/fticonyi
  return(-fbiconyiti)
}


#posterior distribution of random effect bi, i.e., f(bi|ti,yi), for bivaraite functional t copula joint model
fbiPBCpostcop=function(beta1,beta2,D11,D22,D12,etapar,lambda,sigma,alpha,mupar,muord,etaord,data,dynati,bi,m,tmax,nu)
{
  timepoint=data$year
  ni=length(timepoint)
  D=matrix(c(D11,D12,D12,D22),ncol=2)
  a=GaussianHermite(m)[[2]]
  w=GaussianHermite(m)[[1]]
  Xi1=matrix(c(as.numeric(data$drug)-1,as.numeric(data$sex)-1,data$age),ncol=3)
  Zi1=matrix(c(rep(1,ni),timepoint),ncol=2)
  Xi2=c(unique(as.numeric(data$drug)-1),unique(as.numeric(data$sex)-1),unique(data$age))
  mu=eval.basis(timepoint,create.bspline.basis(c(0,tmax),nbasis=length(mupar),norder=muord))%*%mupar
  etaty=eval.basis(timepoint,create.bspline.basis(c(0,tmax),nbasis=length(etapar),norder=etaord))%*%etapar
  rhoty=(exp(2*etaty)-1)/(exp(2*etaty)+1)
  event=unique(data$status2)
  obsti=unique(data$years)
  if(dynati<obsti) {indi=0
  ti=dynati} else {indi=event
  ti=obsti}
  dimyi=sum(timepoint<=ti)
  V11=matrix(Zi1[1:dimyi,],ncol=2)%*%D%*%t(matrix(Zi1[1:dimyi,],ncol=2))+sigma^2*diag(dimyi)
  V22=D
  V12=matrix(Zi1[1:dimyi,],ncol=2)%*%D
  V21=t(V12)
  mubiconyi=V21%*%solve(V11)%*%(log(data$serBilir)-Xi1%*%beta1-mu)[1:dimyi,]
  Sigmabiconyi=V22-V21%*%solve(V11)%*%V12
  Ci=c(lambda,lambda[length(lambda)])*exp(c(Xi2%*%beta2)+alpha*bi[1])
  numbasi=sum(ti>seq(0,max(pbc2$years),length=length(lambda)+1))             #use numnode in the next report
  nodei=c(seq(0,max(pbc2$years),length=length(lambda)+1)[1:numbasi],ti)
  ftikconyibi=1
  if(dimyi>1)
  {
    for(k in 1:(dimyi-1))
    {
      nodeik=c(timepoint[k],nodei[nodei>timepoint[k]][which(nodei[nodei>timepoint[k]] %in% nodei[nodei<timepoint[k+1]])],timepoint[k+1])
      numbasik=length(nodeik)-1
      lownumbasik=sum(timepoint[k]>=nodei)
      upnumbasik=sum(timepoint[k+1]>nodei)
      Sik=exp(sum(-Ci[lownumbasik:upnumbasik]/(alpha*bi[2])*(exp(alpha*bi[2]*nodeik[2:(numbasik+1)])-exp(alpha*bi[2]*nodeik[1:numbasik]))))
      Wyik=qt(pnorm((log(data$serBilir)-Xi1%*%beta1-mu-Zi1%*%bi)[k,]/sigma),df=nu)
      mutikconyibi=rhoty[k]*Wyik
      sigmatikconyibi=sqrt((nu+Wyik^2)*(1-rhoty[k]^2)/(nu+1))
      Stikconyibi=pt((qt(Sik,df=nu)+mutikconyibi)/sigmatikconyibi,df=nu+1)
      ftikconyibi=ftikconyibi*Stikconyibi 
    }
  }
  if(ti!=timepoint[dimyi])
  {
    nodeini=c(timepoint[dimyi],nodei[nodei>timepoint[dimyi]][which(nodei[nodei>timepoint[dimyi]] %in% nodei[nodei<ti])],ti)
    numbasini=length(nodeini)-1
    lownumbasini=sum(timepoint[dimyi]>=nodei)
    upnumbasini=numbasi
    hini=Ci[upnumbasini]*exp(alpha*bi[2]*ti)
    Sini=exp(sum(-Ci[lownumbasini:upnumbasini]/(alpha*bi[2])*(exp(alpha*bi[2]*nodeini[2:(numbasini+1)])-exp(alpha*bi[2]*nodeini[1:numbasini]))))
    fini=hini*Sini
    Wyini=qt(pnorm((log(data$serBilir)-Xi1%*%beta1-mu-Zi1%*%bi)[dimyi,]/sigma),df=nu)
    mutiniconyibi=rhoty[dimyi]*Wyini
    sigmatiniconyibi=sqrt((nu+Wyini^2)*(1-rhoty[dimyi]^2)/(nu+1))
    ftiniconyibi=indi*(dt((-qt(Sini,df=nu)-mutiniconyibi)/sigmatiniconyibi,df=nu+1)/sigmatiniconyibi)*fini/dt(-qt(Sini,df=nu),df=nu)+
      (1-indi)*pt((qt(Sini,df=nu)+mutiniconyibi)/sigmatiniconyibi,df=nu+1)
  } else {ftiniconyibi=1}
  fticonyibi=ftikconyibi*ftiniconyibi
  ftijkconyibi=1
  roti1=matrix(c(cos(pi/4),sin(pi/4),-sin(pi/4),cos(pi/4)),ncol=2)
  roti=eigen(Sigmabiconyi)$vector%*%diag(sqrt(eigen(Sigmabiconyi)$value))%*%roti1
  bij=sqrt(2)*roti%*%t(as.matrix(expand.grid(a,a)))+c(mubiconyi)
  wij=expand.grid(w,w)[,1]*expand.grid(w,w)[,2]/pi
  Cij=c(lambda,lambda[length(lambda)])%*%t(exp(c(Xi2%*%beta2)+alpha*bij[1,]))
  if(dimyi>1)
  {
    for(k in 1:(dimyi-1))
    {
      nodeik=c(timepoint[k],nodei[nodei>timepoint[k]][which(nodei[nodei>timepoint[k]] %in% nodei[nodei<timepoint[k+1]])],timepoint[k+1])
      numbasik=length(nodeik)-1
      lownumbasik=sum(timepoint[k]>=nodei)
      upnumbasik=sum(timepoint[k+1]>nodei)
      Sijk=exp(colSums(-Cij[lownumbasik:upnumbasik,]/(matrix(rep(alpha*bij[2,],numbasik),byrow=T,nrow=numbasik))*
                         (exp(nodeik[2:(numbasik+1)]%*%t(alpha*bij[2,]))-exp(nodeik[1:numbasik]%*%t(alpha*bij[2,])))))  
      Wyijk=qt(pnorm((matrix(rep(log(data$serBilir),m^2),ncol=m^2)-matrix(rep(Xi1%*%beta1+mu,m^2),ncol=m^2)-Zi1%*%bij)[k,]/sigma),df=nu)
      mutijkconyibi=rhoty[k]*Wyijk
      sigmatijkconyibi=sqrt((nu+Wyijk^2)*(1-rhoty[k]^2)/(nu+1))
      Stijkconyibi=pt((qt(Sijk,df=nu)+mutijkconyibi)/sigmatijkconyibi,df=nu+1)
      ftijkconyibi=ftijkconyibi*Stijkconyibi 
    }
  }
  if(ti!=timepoint[dimyi])
  {
    nodeini=c(timepoint[dimyi],nodei[nodei>timepoint[dimyi]][which(nodei[nodei>timepoint[dimyi]] %in% nodei[nodei<ti])],ti)
    numbasini=length(nodeini)-1
    lownumbasini=sum(timepoint[dimyi]>=nodei)
    upnumbasini=numbasi
    hijni=Cij[upnumbasini,]*exp(alpha*bij[2,]*ti)
    Sijni=exp(colSums(-Cij[lownumbasini:upnumbasini,]/(matrix(rep(alpha*bij[2,],numbasini),byrow=T,nrow=numbasini))*
                        (exp(nodeini[2:(numbasini+1)]%*%t(alpha*bij[2,]))-exp(nodeini[1:numbasini]%*%t(alpha*bij[2,])))))
    fijni=hijni*Sijni  
    Wyijni=qt(pnorm((matrix(rep(log(data$serBilir),m^2),ncol=m^2)-matrix(rep(Xi1%*%beta1+mu,m^2),ncol=m^2)-Zi1%*%bij)[dimyi,]/sigma),df=nu)
    mutijniconyibi=rhoty[dimyi]*Wyijni
    sigmatijniconyibi=sqrt((nu+Wyijni^2)*(1-rhoty[dimyi]^2)/(nu+1))
    ftijniconyibi=indi*(dt((-qt(Sijni,df=nu)-mutijniconyibi)/sigmatijniconyibi,df=nu+1)/sigmatijniconyibi)*fijni/dt(-qt(Sijni,df=nu),df=nu)+
      (1-indi)*pt((qt(Sijni,df=nu)+mutijniconyibi)/sigmatijniconyibi,df=nu+1)
  } else {ftijniconyibi=1}
  fticonyi=sum(ftijkconyibi*ftijniconyibi*wij)
  fbiconyiti=fticonyibi*dmvnorm(bi,c(mubiconyi),Sigmabiconyi)/fticonyi
  return(-fbiconyiti)
}

#posterior distribution of random effect bi, i.e., f(bi|ti,yi), for regular joint model (conditional independence)
#This is essential rho(t)=0 under the bivariate functional Gaussain copula joint model
fbiPBCposuncor=function(beta1,beta2,D11,D22,D12,lambda,sigma,alpha,mupar,muord,data,dynati,bi,m,tmax)
{
  timepoint=data$year
  ni=length(timepoint)
  D=matrix(c(D11,D12,D12,D22),ncol=2)
  a=GaussianHermite(m)[[2]]
  w=GaussianHermite(m)[[1]]
  Xi1=matrix(c(as.numeric(data$drug)-1,as.numeric(data$sex)-1,data$age),ncol=3)
  Zi1=matrix(c(rep(1,ni),timepoint),ncol=2)
  Xi2=c(unique(as.numeric(data$drug)-1),unique(as.numeric(data$sex)-1),unique(data$age))
  mu=eval.basis(timepoint,create.bspline.basis(c(0,tmax),nbasis=length(mupar),norder=muord))%*%mupar
  event=unique(data$status2)
  obsti=unique(data$years)
  if(dynati<obsti) {indi=0
  ti=dynati} else {indi=event
  ti=obsti}
  dimyi=sum(timepoint<=ti)
  V11=matrix(Zi1[1:dimyi,],ncol=2)%*%D%*%t(matrix(Zi1[1:dimyi,],ncol=2))+sigma^2*diag(dimyi)
  V22=D
  V12=matrix(Zi1[1:dimyi,],ncol=2)%*%D
  V21=t(V12)
  mubiconyi=V21%*%solve(V11)%*%(log(data$serBilir)-Xi1%*%beta1-mu)[1:dimyi,]
  Sigmabiconyi=V22-V21%*%solve(V11)%*%V12
  Ci=c(lambda,lambda[length(lambda)])*exp(c(Xi2%*%beta2)+alpha*bi[1])
  numbasi=sum(ti>seq(0,max(pbc2$years),length=length(lambda)+1))
  nodei=c(seq(0,max(pbc2$years),length=length(lambda)+1)[1:numbasi],ti)
  ftikconyibi=1
  if(dimyi>1)
  {
    for(k in 1:(dimyi-1))
    {
      nodeik=c(timepoint[k],nodei[nodei>timepoint[k]][which(nodei[nodei>timepoint[k]] %in% nodei[nodei<timepoint[k+1]])],timepoint[k+1])
      numbasik=length(nodeik)-1
      lownumbasik=sum(timepoint[k]>=nodei)
      upnumbasik=sum(timepoint[k+1]>nodei)
      Sik=exp(sum(-Ci[lownumbasik:upnumbasik]/(alpha*bi[2])*(exp(alpha*bi[2]*nodeik[2:(numbasik+1)])-exp(alpha*bi[2]*nodeik[1:numbasik]))))   
      ftikconyibi=ftikconyibi*Sik
    }
  }
  if(ti!=timepoint[dimyi])
  {
    nodeini=c(timepoint[dimyi],nodei[nodei>timepoint[dimyi]][which(nodei[nodei>timepoint[dimyi]] %in% nodei[nodei<ti])],ti)
    numbasini=length(nodeini)-1
    lownumbasini=sum(timepoint[dimyi]>=nodei)
    upnumbasini=numbasi
    hini=Ci[upnumbasini]*exp(alpha*bi[2]*ti)
    Sini=exp(sum(-Ci[lownumbasini:upnumbasini]/(alpha*bi[2])*(exp(alpha*bi[2]*nodeini[2:(numbasini+1)])-exp(alpha*bi[2]*nodeini[1:numbasini]))))
    fini=hini*Sini
    ftiniconyibi=indi*fini+(1-indi)*Sini
  } else {ftiniconyibi=1}
  fticonyibi=ftikconyibi*ftiniconyibi
  ftijkconyibi=1
  roti1=matrix(c(cos(pi/4),sin(pi/4),-sin(pi/4),cos(pi/4)),ncol=2)
  roti=eigen(Sigmabiconyi)$vector%*%diag(sqrt(eigen(Sigmabiconyi)$value))%*%roti1
  bij=sqrt(2)*roti%*%t(as.matrix(expand.grid(a,a)))+c(mubiconyi)
  wij=expand.grid(w,w)[,1]*expand.grid(w,w)[,2]/pi
  Cij=c(lambda,lambda[length(lambda)])%*%t(exp(c(Xi2%*%beta2)+alpha*bij[1,]))
  if(dimyi>1)
  {
    for(k in 1:(dimyi-1))
    {
      nodeik=c(timepoint[k],nodei[nodei>timepoint[k]][which(nodei[nodei>timepoint[k]] %in% nodei[nodei<timepoint[k+1]])],timepoint[k+1])
      numbasik=length(nodeik)-1
      lownumbasik=sum(timepoint[k]>=nodei)
      upnumbasik=sum(timepoint[k+1]>nodei)
      Sijk=exp(colSums(-Cij[lownumbasik:upnumbasik,]/(matrix(rep(alpha*bij[2,],numbasik),byrow=T,nrow=numbasik))*
                         (exp(nodeik[2:(numbasik+1)]%*%t(alpha*bij[2,]))-exp(nodeik[1:numbasik]%*%t(alpha*bij[2,])))))  
      ftijkconyibi=ftijkconyibi*Sijk
    }
  }
  if(ti!=timepoint[dimyi])
  {
    nodeini=c(timepoint[dimyi],nodei[nodei>timepoint[dimyi]][which(nodei[nodei>timepoint[dimyi]] %in% nodei[nodei<ti])],ti)
    numbasini=length(nodeini)-1
    lownumbasini=sum(timepoint[dimyi]>=nodei)
    upnumbasini=numbasi
    hijni=Cij[upnumbasini,]*exp(alpha*bij[2,]*ti)
    Sijni=exp(colSums(-Cij[lownumbasini:upnumbasini,]/(matrix(rep(alpha*bij[2,],numbasini),byrow=T,nrow=numbasini))*
                        (exp(nodeini[2:(numbasini+1)]%*%t(alpha*bij[2,]))-exp(nodeini[1:numbasini]%*%t(alpha*bij[2,])))))
    fijni=hijni*Sijni  
    ftijniconyibi=indi*fijni+(1-indi)*Sijni
  } else {ftijniconyibi=1}
  fticonyi=sum(ftijkconyibi*ftijniconyibi*wij)
  fbiconyiti=fticonyibi*dmvnorm(bi,c(mubiconyi),Sigmabiconyi)/fticonyi
  return(-fbiconyiti)
}

#"fbiPBCposuncor.2" is equivalent to "fbiPBCposuncor"
fbiPBCposuncor.2=function(beta1,beta2,D11,D22,D12,lambda,sigma,alpha,mupar,muord,data,dynati,bi,m,tmax)
{
  timepoint=data$year
  ni=length(timepoint)
  D=matrix(c(D11,D12,D12,D22),ncol=2)
  a=GaussianHermite(m)[[2]]
  w=GaussianHermite(m)[[1]]
  Xi1=matrix(c(as.numeric(data$drug)-1,as.numeric(data$sex)-1,data$age),ncol=3)
  Zi1=matrix(c(rep(1,ni),timepoint),ncol=2)
  Xi2=c(unique(as.numeric(data$drug)-1),unique(as.numeric(data$sex)-1),unique(data$age))
  mu=eval.basis(timepoint,create.bspline.basis(c(0,tmax),nbasis=length(mupar),norder=muord))%*%mupar
  event=unique(data$status2)
  obsti=unique(data$years)
  if(dynati<obsti) {indi=0
  ti=dynati} else {indi=event
  ti=obsti}
  dimyi=sum(timepoint<=ti)
  V11=matrix(Zi1[1:dimyi,],ncol=2)%*%D%*%t(matrix(Zi1[1:dimyi,],ncol=2))+sigma^2*diag(dimyi)
  V22=D
  V12=matrix(Zi1[1:dimyi,],ncol=2)%*%D
  V21=t(V12)
  mubiconyi=V21%*%solve(V11)%*%(log(data$serBilir)-Xi1%*%beta1-mu)[1:dimyi,]
  Sigmabiconyi=V22-V21%*%solve(V11)%*%V12
  Ci=c(lambda,lambda[length(lambda)])*exp(c(Xi2%*%beta2)+alpha*bi[1])
  numbasi=sum(ti>=seq(0,max(pbc2$years),length=length(lambda)+1))
  nodei=c(seq(0,max(pbc2$years),length=length(lambda)+1)[1:numbasi],ti)
  Si=exp(sum(-Ci[1:numbasi]/(alpha*bi[2])*(exp(alpha*bi[2]*nodei[2:(numbasi+1)])-exp(alpha*bi[2]*nodei[1:numbasi]))))   
  hi=Ci[numbasi]*exp(alpha*bi[2]*ti)
  fi=hi*Si
  fticonyibi=indi*fi+(1-indi)*Si
  roti1=matrix(c(cos(pi/4),sin(pi/4),-sin(pi/4),cos(pi/4)),ncol=2)
  roti=eigen(Sigmabiconyi)$vector%*%diag(sqrt(eigen(Sigmabiconyi)$value))%*%roti1
  bij=sqrt(2)*roti%*%t(as.matrix(expand.grid(a,a)))+c(mubiconyi)
  wij=expand.grid(w,w)[,1]*expand.grid(w,w)[,2]/pi
  Cij=c(lambda,lambda[length(lambda)])%*%t(exp(c(Xi2%*%beta2)+alpha*bij[1,]))
  Sij=exp(colSums(-Cij[1:numbasi,]/(matrix(rep(alpha*bij[2,],numbasi),byrow=T,nrow=numbasi))*
                    (exp(nodei[2:(numbasi+1)]%*%t(alpha*bij[2,]))-exp(nodei[1:numbasi]%*%t(alpha*bij[2,])))))  
  hij=Cij[numbasi,]*exp(alpha*bij[2,]*ti)
  fij=hij*Sij  
  ftijconyibi=indi*fij+(1-indi)*Sij
  fticonyi=sum(ftijconyibi*wij)
  fbiconyiti=fticonyibi*dmvnorm(bi,c(mubiconyi),Sigmabiconyi)/fticonyi
  return(-fbiconyiti)
}


#maximise f(bi|ti,yi) to obtain hat^{bi} for bivaraite functional copula joint model
dynaPBCbi=function(beta1,beta2,D11,D22,D12,etapar,lambda,sigma,alpha,mupar,muord,etaord,data,dynati,m,tmax,mtool,copula,nu)
{
  timepoint=data$year
  ni=length(timepoint)
  D=matrix(c(D11,D12,D12,D22),ncol=2)
  Xi1=matrix(c(as.numeric(data$drug)-1,as.numeric(data$sex)-1,data$age),ncol=3)
  Zi1=matrix(c(rep(1,ni),timepoint),ncol=2)
  Xi2=c(unique(as.numeric(data$drug)-1),unique(as.numeric(data$sex)-1),unique(data$age))
  mu=eval.basis(timepoint,create.bspline.basis(c(0,tmax),nbasis=length(mupar),norder=muord))%*%mupar
  obsti=unique(data$years)
  ti=min(dynati,obsti)
  dimyi=sum(timepoint<=ti)
  V11=matrix(Zi1[1:dimyi,],ncol=2)%*%D%*%t(matrix(Zi1[1:dimyi,],ncol=2))+sigma^2*diag(dimyi)
  V22=D
  V12=matrix(Zi1[1:dimyi,],ncol=2)%*%D
  V21=t(V12)
  mubiconyi=V21%*%solve(V11)%*%(log(data$serBilir)-Xi1%*%beta1-mu)[1:dimyi,]
  if(copula=="Gaucop")
  {
    etaty=eval.basis(timepoint,create.bspline.basis(c(0,tmax),nbasis=length(etapar),norder=etaord))%*%etapar
    rhoty=(exp(2*etaty)-1)/(exp(2*etaty)+1)
    if(mtool=="nlm")
    {
    bihat=nlm(fbiPBCposGau,p=c(mubiconyi),beta1=beta1,beta2=beta2,D11=D11,D22=D22,D12=D12,etapar=etapar,lambda=lambda,
              sigma=sigma,alpha=alpha,mupar=mupar,muord=muord,etaord=etaord,data=data,dynati=dynati,m=m,tmax=tmax,
              hessian=T,iterlim=10000)$est } else {
    bihat=optim(fbiPBCposGau,p=c(mubiconyi),beta1=beta1,beta2=beta2,D11=D11,D22=D22,D12=D12,etapar=etapar,lambda=lambda,
              sigma=sigma,alpha=alpha,mupar=mupar,muord=muord,etaord=etaord,data=data,dynati=dynati,m=m,tmax=tmax,
              hessian=T,control=list(maxit=20000))$par }
                
  }
  if(copula=="tcop")
  {
    etaty=eval.basis(timepoint,create.bspline.basis(c(0,tmax),nbasis=length(etapar),norder=etaord))%*%etapar
    rhoty=(exp(2*etaty)-1)/(exp(2*etaty)+1)
    if(mtool=="nlm")
    {
    bihat=nlm(fbiPBCpostcop,p=c(mubiconyi),beta1=beta1,beta2=beta2,D11=D11,D22=D22,D12=D12,etapar=etapar,lambda=lambda,
              sigma=sigma,alpha=alpha,mupar=mupar,muord=muord,etaord=etaord,data=data,dynati=dynati,m=m,tmax=tmax,nu=nu,
              hessian=T,iterlim=10000)$est } else {
    bihat=optim(fbiPBCpostcop,p=c(mubiconyi),beta1=beta1,beta2=beta2,D11=D11,D22=D22,D12=D12,etapar=etapar,lambda=lambda,
              sigma=sigma,alpha=alpha,mupar=mupar,muord=muord,etaord=etaord,data=data,dynati=dynati,m=m,tmax=tmax,nu=nu,
              hessian=T,control=list(maxit=20000))$par }
  }
  if(copula=="uncor")
  {
    if(mtool=="nlm")
    {
    bihat=nlm(fbiPBCposuncor,p=c(mubiconyi),beta1=beta1,beta2=beta2,D11=D11,D22=D22,D12=D12,lambda=lambda,
              sigma=sigma,alpha=alpha,mupar=mupar,muord=muord,data=data,dynati=dynati,m=m,tmax=tmax,
              hessian=T,iterlim=10000)$est } else {
    bihat=optim(fbiPBCposuncor,p=c(mubiconyi),beta1=beta1,beta2=beta2,D11=D11,D22=D22,D12=D12,lambda=lambda,
              sigma=sigma,alpha=alpha,mupar=mupar,muord=muord,data=data,dynati=dynati,m=m,tmax=tmax,
              hessian=T,control=list(maxit=20000))$par  }
  }
  if(copula=="uncor2")
  {
    if(mtool=="nlm")
    {
    bihat=nlm(fbiPBCposuncor.2,p=c(mubiconyi),beta1=beta1,beta2=beta2,D11=D11,D22=D22,D12=D12,lambda=lambda,
              sigma=sigma,alpha=alpha,mupar=mupar,muord=muord,data=data,dynati=dynati,m=m,tmax=tmax,
              hessian=T,iterlim=10000)$est } else {
    bihat=optim(fbiPBCposuncor.2,p=c(mubiconyi),beta1=beta1,beta2=beta2,D11=D11,D22=D22,D12=D12,lambda=lambda,
              sigma=sigma,alpha=alpha,mupar=mupar,muord=muord,data=data,dynati=dynati,m=m,tmax=tmax,
              hessian=T,control=list(maxit=20000))$par   }
  }
  results=list(bihat,c(mubiconyi))
  return(results)
}


#predict survival probabilities of PBC data
predPBCSur=function(beta1,beta2,D11,D22,D12,etapar,lambda,sigma,alpha,mupar,muord,etaord,data,dynati,predinterv,m,tmax,mtool,acc,copula,nu)
{
  timepoint=data$year
  ni=length(timepoint)
  D=matrix(c(D11,D12,D12,D22),ncol=2)
  Xi1=matrix(c(as.numeric(data$drug)-1,as.numeric(data$sex)-1,data$age),ncol=3)
  Zi1=matrix(c(rep(1,ni),timepoint),ncol=2)
  Xi2=c(unique(as.numeric(data$drug)-1),unique(as.numeric(data$sex)-1),unique(data$age))
  mu=eval.basis(timepoint,create.bspline.basis(c(0,tmax),nbasis=length(mupar),norder=muord))%*%mupar
  obsti=unique(data$years)
  ti=seq(min(dynati,obsti),predinterv,by=acc)
  dimyi=sum(timepoint<=min(dynati,obsti))
  outbi=dynaPBCbi(beta1=beta1,beta2=beta2,D11=D11,D22=D22,D12=D12,etapar=etapar,lambda=lambda,sigma=sigma,alpha=alpha,
                  mupar=mupar,muord=muord,etaord=etaord,data=data,dynati=dynati,m=m,tmax=tmax,mtool=mtool,copula=copula,nu=nu)
  hatbi=outbi[[1]]
  hatbiconyi=outbi[[2]]
  Ci=c(lambda,lambda[length(lambda)])*exp(c(Xi2%*%beta2)+alpha*hatbi[1])
  node=seq(0,max(pbc2$years),length=length(lambda)+1)
  Sicon=0
  for(k in 1:length(ti))
  {
    nodeik=c(timepoint[dimyi],node[node>timepoint[dimyi]][which(node[node>timepoint[dimyi]] %in% node[node<ti[k]])],ti[k])
    numbasik=length(nodeik)-1
    lownumbasik=sum(timepoint[dimyi]>=node)
    upnumbasik=sum(ti[k]>node)
    Cik=Ci[lownumbasik:upnumbasik]
    Sicon[k]=exp(sum(-Cik/(alpha*hatbi[2])*(exp(alpha*hatbi[2]*nodeik[2:(numbasik+1)])-exp(alpha*hatbi[2]*nodeik[1:numbasik]))))  
  }
  if(copula=="Gaucop")
  {
    etaty=eval.basis(timepoint,create.bspline.basis(c(0,tmax),nbasis=length(etapar),norder=etaord))%*%etapar 
    rhoty=(exp(2*etaty)-1)/(exp(2*etaty)+1)
    Zyi=(log(data$serBilir)-Xi1%*%beta1-mu-Zi1%*%hatbi)[dimyi,]/sigma
    muticonyibi=rhoty[dimyi]*Zyi
    sigmaticonyibi=sqrt(1-rhoty[dimyi]^2)
    predi=pnorm((qnorm(Sicon)+muticonyibi)/sigmaticonyibi)/pnorm((qnorm(Sicon[1])+muticonyibi)/sigmaticonyibi)
  }
  if (copula=="tcop")
  {
    etaty=eval.basis(timepoint,create.bspline.basis(c(0,tmax),nbasis=length(etapar),norder=etaord))%*%etapar 
    rhoty=(exp(2*etaty)-1)/(exp(2*etaty)+1)
    Wyi=qt(pnorm((log(data$serBilir)-Xi1%*%beta1-mu-Zi1%*%hatbi)[dimyi,]/sigma),df=nu)
    muticonyibi=rhoty[dimyi]*Wyi
    sigmaticonyibi=sqrt((nu+Wyi^2)*(1-rhoty[dimyi]^2)/(nu+1))
    predi=pt((qt(Sicon,df=nu)+muticonyibi)/sigmaticonyibi,df=nu+1)/pt((qt(Sicon[1],df=nu)+muticonyibi)/sigmaticonyibi,df=nu+1)
  }
  if(copula=="uncor"|copula=="uncor2")
  {
    predi=Sicon/Sicon[1]
  }
  results=list(ti,Sicon/Sicon[1],predi,dimyi,hatbi,hatbiconyi)
  return(results)
}

#calculate AUC and PE for PBC data

dynaPBCsurgroup.cen=function(Data,beta1,beta2,D11,D22,D12,etapar,lambda,sigma,alpha,mupar,muord,etaord,dynati,predinterv,
                             m,tmax,mtool,copula,nu)
{
  allprob=0
  j=0
  i=1
  ind=0
  obst=0
  for (i in c(unique(Data$id)))
  { 
    Datai=Data[Data$id==i,]
    obsti=unique(Datai$years)
    indi=unique(Datai$status2)
    if(obsti>dynati)
    {
      j=j+1
      allprob[j]=predPBCSur(beta1=beta1,beta2=beta2,D11=D11,D22=D22,D12=D12,etapar=etapar,lambda=lambda,
                            sigma=sigma,alpha=alpha,mupar=mupar,muord=muord,etaord=etaord,data=Datai,dynati=dynati,
                            predinterv=predinterv,m=m,tmax=tmax,mtool=mtool,acc=predinterv-dynati,copula=copula,nu=nu)[[3]][-1]
      ind[j]=indi;obst[j]=obsti
    }
  }
  results=list(j,allprob,ind,obst)
  return(results)
}


dynaAUC.cen=function(probs,ind,obst,dynati,predinterv)
{
  upcount=0;lowcount=0
  for(i in 1:length(probs))
  {
    if(obst[i]<=predinterv&obst[i]>dynati&ind[i]==1)
    {
      upcount=sum((obst>predinterv)*(probs[i]<probs))+sum((obst>obst[i]&obst<=predinterv&ind==0)*(probs[i]<probs)*probs)+
        upcount
      lowcount=sum(obst>predinterv)+sum((obst>obst[i]&obst<=predinterv&ind==0)*probs)+lowcount
    }
    if(obst[i]<=predinterv&obst[i]>dynati&ind[i]==0)
    {
      upcount=sum((obst>predinterv)*(probs[i]<probs)*(1-probs[i]))+
        sum((obst>obst[i]&obst<=predinterv&ind==0)*(probs[i]<probs)*(1-probs[i])*probs)+upcount
      lowcount=sum((obst>predinterv)*(1-probs[i]))+sum((obst>obst[i]&obst<=predinterv&ind==0)*(1-probs[i])*probs)+
        lowcount
    }
  }
  return(upcount/lowcount)
}


dynaBS.cen=function(probs,ind,obst,dynati,predinterv)
{
     upcount=sum((obst>predinterv)*(1-probs)^2+ind*(obst<predinterv)*(0-probs)^2+(1-ind)*(obst<predinterv)*
                   (probs*(1-probs)^2+(1-probs)*(0-probs)^2))
    lowcount=sum(obst>dynati)
  return(upcount/lowcount)
}


#Estimate parameter by leave one out cross validation
PBC.funparest.leaveoneout=function(theta,nu,m,N)
{
  estmatrixGau.muBS4.etaBS5=NULL
  estmatrixtcop.muBS4.etaBS5=NULL
  estmatrixGau.muBS4.uncor=NULL
  gradmatrixGau.muBS4.etaBS5=NULL
  gradmatrixtcop.muBS4.etaBS5=NULL
  gradmatrixGau.muBS4.uncor=NULL
  loglikmatrix=NULL
  codematrix=NULL
  itermatrix=NULL
  for(i in 1:N)
  {
    fitdata=pbc2[pbc2$id!=i,]
    estGHObGau.muBS4.etaBS5=nlm(f=appPBCbivGaucoploglik.funrhoty.mu,p=c(theta[1:9],rep(0,5),theta[10:22]),data=fitdata,
                        neta=5,nmu=4,etaord=5,muord=4,nlam=7,tmax=max(pbc2$year),m=m,hessian=T,iterlim=2000)
    estGHObtcop.muBS4.etaBS5=nlm(f=appPBCbivtcoploglik.funrhoty.mu,p=c(theta[1:9],rep(0,5),theta[10:22]),data=fitdata,
                        neta=5,nmu=4,etaord=5,muord=4,nlam=7,tmax=max(pbc2$year),nu=nu,m=m,hessian=T,iterlim=2000)
    estGHObGau.muBS4.uncor=nlm(f=appPBCbivGaucoploglik.uncor.funmu,p=theta,data=fitdata,m=m,hessian=T,iterlim=2000,
                        nmu=4,muord=4,nlam=7,tmax=max(pbc2$year))
    estmatrixGau.muBS4.etaBS5=rbind(estmatrixGau.muBS4.etaBS5,estGHObGau.muBS4.etaBS5$estimate)
    estmatrixtcop.muBS4.etaBS5=rbind(estmatrixtcop.muBS4.etaBS5,estGHObtcop.muBS4.etaBS5$estimate)
    estmatrixGau.muBS4.uncor=rbind(estmatrixGau.muBS4.uncor,estGHObGau.muBS4.uncor$estimate)
    gradmatrixGau.muBS4.etaBS5=rbind(gradmatrixGau.muBS4.etaBS5,estGHObGau.muBS4.etaBS5$gradient)
    gradmatrixtcop.muBS4.etaBS5=rbind(gradmatrixtcop.muBS4.etaBS5,estGHObtcop.muBS4.etaBS5$gradient)
    gradmatrixGau.muBS4.uncor=rbind(gradmatrixGau.muBS4.uncor,estGHObGau.muBS4.uncor$gradient)
    loglikmatrix=rbind(loglikmatrix,c(-estGHObGau.muBS4.etaBS5$minimum,-estGHObtcop.muBS4.etaBS5$minimum,
                                      -estGHObGau.muBS4.uncor$minimum))
    codematrix=rbind(codematrix,c(estGHObGau.muBS4.etaBS5$code,estGHObtcop.muBS4.etaBS5$code,
                                  estGHObGau.muBS4.uncor$code))
    itermatrix=rbind(itermatrix,c(estGHObGau.muBS4.etaBS5$iter,estGHObtcop.muBS4.etaBS5$iter,
                                  estGHObGau.muBS4.uncor$iter))
    print(i)
  }
  colnames(gradmatrixGau.muBS4.etaBS5)=c('gbeta11','gbeta21','gbeta31','gbeta12','gbeta22','gbeta32',
                                      'gD11','gD22','gD12',rep('getapar',5),rep('glambda',7),'gsigma','galpha',rep('gmupar',4))
  colnames(estmatrixGau.muBS4.etaBS5)=c('beta11','beta21','beta31','beta12','beta22','beta32',
                                      'D11','D22','D12',rep('etapar',5),rep('lambda',7),'sigma','alpha',rep('mupar',4))
  colnames(gradmatrixtcop.muBS4.etaBS5)=c('gbeta11','gbeta21','gbeta31','gbeta12','gbeta22','gbeta32',
                                      'gD11','gD22','gD12',rep('getapar',5),rep('glambda',7),'gsigma','galpha',rep('gmupar',4))
  colnames(estmatrixtcop.muBS4.etaBS5)=c('beta11','beta21','beta31','beta12','beta22','beta32',
                                       'D11','D22','D12',rep('etapar',5),rep('lambda',7),'sigma','alpha',rep('mupar',4))
  colnames(gradmatrixGau.muBS4.uncor)=c('gbeta11','gbeta21','gbeta31','gbeta12','gbeta22','gbeta32',
                                        'gD11','gD22','gD12',rep('glambda',7),'gsigma','galpha',rep('gmupar',4))
  colnames(estmatrixGau.muBS4.uncor)=c('beta11','beta21','beta31','beta12','beta22','beta32',
                                       'D11','D22','D12',rep('lambda',7),'sigma','alpha',rep('mupar',4))
  results=list(gradmatrixGau.muBS4.etaBS5,gradmatrixtcop.muBS4.etaBS5,gradmatrixGau.muBS4.uncor,
               estmatrixGau.muBS4.etaBS5,estmatrixtcop.muBS4.etaBS5,estmatrixGau.muBS4.uncor,
               colMeans(estmatrixGau.muBS4.etaBS5),colMeans(estmatrixtcop.muBS4.etaBS5),
               colMeans(estmatrixGau.muBS4.uncor),loglikmatrix,codematrix,itermatrix)
  return(results)
}

